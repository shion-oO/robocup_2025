<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>交差点付きライントレース</title>
  <style>
    body {
      font-family: 'Helvetica Neue', sans-serif;
      background-color: #f0f4f8;
      margin: 0;
      padding: 0;
      color: #2c3e50;
    }

    header {
      background-color: #3498db;
      color: white;
      padding: 20px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: 2em;
    }

    nav {
      background-color: #ecf0f1;
      padding: 10px 20px;
      text-align: center;
    }

    nav a {
      color: #3498db;
      text-decoration: none;
      margin: 0 15px;
      font-weight: bold;
    }

    nav a:hover {
      text-decoration: underline;
    }

    main {
      padding: 40px 20px;
      max-width: 1200px;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    video {
      width: 100%;
      max-width: 640px;
      border-radius: 10px;
      display: block;
      margin: 0 auto;
    }

    .caption {
      margin-top: 12px;
      font-size: 16px;
      color: #444;
      text-align: center;
      margin-bottom: 60px;
    }

    h2 {
      color: #3498db;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
      margin-top: 40px;
    }

    .code-section {
      display: flex;
      gap: 30px;
      margin-top: 30px;
      margin-bottom: 70px;
      flex-wrap: wrap;
    }

    .code-box {
      flex: 1;
      min-width: 480px;
      background: #f7f9fb;
      border-radius: 10px;
      padding: 25px;
      overflow-x: auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    pre {
      margin: 0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
      color: #333;
    }

    .desc-box {
      flex: 1;
      min-width: 400px;
      background: #eaf4fc;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .desc-box p {
      margin-bottom: 10px;
      line-height: 1.6;
    }

    /* ▼ 学習セクション ▼ */
    .learn-section {
      margin-top: 60px;
      background-color: #f7f9fb;
      padding: 40px 30px;
      border-radius: 10px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.1);
    }

    .learn-section h2 {
      text-align: center;
      font-size: 1.8em;
      color: #3498db;
      border-bottom: none;
      margin-bottom: 20px;
    }

    .learn-section p {
      font-size: 1.1em;
      line-height: 1.8;
      color: #2c3e50;
      margin-bottom: 15px;
    }

    .learn-list {
      list-style: decimal;
      padding-left: 25px;
      font-size: 1.05em;
      line-height: 1.8;
    }

  </style>
</head>
<body>

  <header>
    <h1>交差点付きライントレース</h1>
  </header>

  <nav>
    <a href="robocup_home.html">ホーム</a>
    <a href="linetrace.html">白黒ライントレース</a>
    <a href="linetrace3.html">ギャップライントレース</a>
    <a href="goal.html">ゴールタイル</a>
  </nav>

  <main>
    <video controls>
      <source src="midori_kenti.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑を検知して、進行方向を判断するロボットの動画です。
    </div>

    <h2>midori_kenti.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code># ① ライブラリのインポート
import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

# ② グローバル変数
last_direction = "RIGHT"

# ③ HSV変換関数
def get_hsv_from_sensor(sensor: ColorSensor):
    r, g, b = sensor.get_raw_color()
    rgb = np.uint8([[[r, g, b]]])
    hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)
    return hsv[0][0]

# ④ 緑色検知関数（左・右）
def is_green_left(h, s, v):
    return (70 <= h <= 90) and (13 <= s <= 30) and (25 <= v <= 35)

def is_green_right(h, s, v):
    return (75 <= h <= 80) and (120 <= s <= 150) and (35 <= v <= 50)

# ⑤ メイン制御関数
def trace_and_turn_on_green(right_motor: Motor, left_motor: Motor,
                            color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction
    try:
        h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
        h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)

        left_is_green = is_green_left(h_l, s_l, v_l)
        right_is_green = is_green_right(h_r, s_r, v_r)

        if left_is_green:
            print(f"[LEFT TURN] Green detected on LEFT sensor (HSV={h_l},{s_l},{v_l})")
            left_motor.set_power(50)
            right_motor.set_power(0)
            time.sleep(1.5)  
            return

        if right_is_green:
            print(f"[RIGHT TURN] Green detected on RIGHT sensor (HSV={h_r},{s_r},{v_r})")
            left_motor.set_power(0)
            right_motor.set_power(50)
            time.sleep(1.5)
            return

        if v_l < 60 and s_l < 100:
            power = 30
            left_motor.set_power(power)
            right_motor.set_power(power)
            last_direction = "STRAIGHT"
        else:
            if last_direction in ["STRAIGHT", "RIGHT"]:
                left_motor.set_power(50)
                right_motor.set_power(0)
                last_direction = "LEFT"
            else:
                left_motor.set_power(0)
                right_motor.set_power(50)
                last_direction = "RIGHT"

        print(f"LEFT HSV=({h_l},{s_l},{v_l}) | RIGHT HSV=({h_r},{s_r},{v_r}) | Dir={last_direction}")

    except Exception as e:
        print(f"[ERROR] {e}")

# ⑥ 実行部分
(ETRobo(backend='raspyke')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='C')
 .add_device('color_sensor_left', device_type=ColorSensor, port='S2')
 .add_device('color_sensor_right', device_type=ColorSensor, port='S3')
 .add_handler(trace_and_turn_on_green)
 .dispatch(interval=0.1))
</code></pre>
      </div>

<div class="desc-box">
  <h3>(プログラムの説明)</h3>

  <p>
    このプログラムは、左右のカラーセンサーで取得した<strong>RGB値</strong>を<strong>HSV色空間</strong>に変換し、  
    緑色を検出した側に合わせて右折・左折を行うように制御します。  
    緑が検出されないときはラインをトレースして直進または補正走行を行います。  
    <strong>eTRobo環境</strong>で実行され、モーター・センサーは<strong>Raspberry Pi</strong>経由で制御されます。
  </p>

  <h4>① ライブラリのインポート</h4>
  <p>
    画像処理ライブラリ（<code>cv2</code>, <code>numpy</code>）と、  
    ETロボコン用デバイス制御ライブラリ（<code>etrobo_python</code>）を読み込んでいます。  
    これにより、ロボットのモーターやカラーセンサーをPythonから操作できるようになります。
  </p>

  <h4>② グローバル変数</h4>
  <p>
    ロボットが<strong>直前にどちらへ進んだか（右・左・直進）</strong>を記録しておくための変数です。  
    次の動作を決める際に参照されます。
  </p>

  <h4>③ HSV変換関数</h4>
  <p>
    センサーから取得したRGB値を、色検出に適した<strong>HSV形式</strong>に変換します。  
    HSVは「色相（Hue）」「彩度（Saturation）」「明度（Value）」を表し、  
    緑色などの判定を安定して行えるようになります。
  </p>

  <h4>④ 緑色検知関数（左・右）</h4>
  <p>
    左右のカラーセンサーで取得したHSV値が、  
    あらかじめ設定された「緑色の範囲」に入っているかを判定します。  
    左右で条件を少し変えているのは、照明環境やセンサー個体差を補正するためです。
  </p>

  <h4>⑤ メイン制御関数</h4>
  <p>
    この関数がロボット走行の中心となる処理です。
  </p>
  <ol>
    <li>HSV値を取得し、左右のカラーセンサーから色データを読み取る。</li>
    <li>緑色が左にあれば左折、右にあれば右折を行う。</li>
    <li>緑がない場合はライントレース（前進・微調整）を行う。</li>
    <li>最後にどちらへ曲がったかを記録し、次回の補正に利用。</li>
  </ol>

  <h4>⑥ 実行部分</h4>
  <p>
    ロボット本体を初期化し、モーターやセンサーを登録します。  
    <code>dispatch(interval=0.1)</code> により、0.1秒ごとに上記の制御関数を繰り返し実行します。
  </p>
</div>


<table border="1" style="border-collapse: collapse; text-align: left;">
  <tr style="background-color: #f0f0f0;">
    <th>問題の内容</th>
    <th>原因</th>
    <th>改善のヒント</th>
  </tr>
  <tr>
    <td>ロボットが動かない</td>
    <td>モーターやセンサーのポート指定が間違っている</td>
    <td>ETRobo初期化部分でポート名（例: 'B', 'C', 'S2', 'S3'）を再確認する</td>
  </tr>
  <tr>
    <td>常に右折または左折しかしない</td>
    <td>緑色判定のHSV範囲が狭すぎる / 照明条件が異なる</td>
    <td>`is_green_left`や`is_green_right`のHSV範囲を少し広げる（例: H±5, S±20など）</td>
  </tr>
  <tr>
    <td>ライン上でふらつく</td>
    <td>センサーの反応遅延またはモーター出力のバランス</td>
    <td>左右モーターの出力比（50と30など）を調整する</td>
  </tr>
  <tr>
    <td>「[ERROR]」が頻発する</td>
    <td>センサー値が取得できていない / コネクタ接触不良</td>
    <td>カラーセンサーのコネクタを抜き差しして再接続する</td>
  </tr>
  <tr>
    <td>緑を検知しても反応しない</td>
    <td>センサー位置が遠すぎる or HSV範囲が合っていない</td>
    <td>センサーの高さを調整し、実際の緑色を`print()`で確認しながら範囲を再設定する</td>
  </tr>
</table>


        <video controls>
      <source src="midori_tyokusin.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑の交差点を検知して、進行方向を判断するロボットの動画です。
    </div>

        <h2>midori_tyokusin.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code>import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

last_direction = "STRAIGHT"
prev_left_power = -1
prev_right_power = -1
last_log_time = 0
ignore_green_until = 0  # ????????

def get_hsv_from_sensor(sensor: ColorSensor):
    r, g, b = sensor.get_raw_color()
    rgb = np.uint8([[[r, g, b]]])
    hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)
    return hsv[0][0]

def is_green(h, s, v):
    return (75 <= h <= 100) and (s == 0 or s >= 60) and v >= 160

def is_black(s, v):
    return s < 100 and v < 80

def set_motor_power_safe(left_motor, right_motor, lp, rp):
    global prev_left_power, prev_right_power
    if lp != prev_left_power:
        left_motor.set_power(lp)
        prev_left_power = lp
    if rp != prev_right_power:
        right_motor.set_power(rp)
        prev_right_power = rp

def trace_with_green_turn(right_motor: Motor, left_motor: Motor,
                          color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction, last_log_time, ignore_green_until

    try:
        h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
        h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)

        left_is_green = is_green(h_l, s_l, v_l)
        right_is_green = is_green(h_r, s_r, v_r)

        left_is_black = is_black(s_l, v_l)
        right_is_black = is_black(s_r, v_r)

        current_time = time.time()

        # --- ?????????????????????? ---
        if left_is_black and right_is_black:
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"
            ignore_green_until = current_time + 0.8  # ??????
            print("[CROSS] BOTH BLACK ? GO STRAIGHT & IGNORE GREEN")
            return
            # --- ??????????????????? ---
        if current_time > ignore_green_until:
            if left_is_green and not left_is_black:
                print(f"[LEFT TURN] GREEN DETECTED: L=({h_l},{s_l},{v_l})")
                start = time.time()
                while time.time() - start < 0.7:
                    set_motor_power_safe(left_motor, right_motor, 100, 0)
                    time.sleep(0.05)
                print("[ADJUST] Turning LEFT adjust")
                set_motor_power_safe(left_motor, right_motor, 30, 100)
                time.sleep(1.0)
                return

            if right_is_green and not right_is_black:
                print(f"[RIGHT TURN] GREEN DETECTED: R=({h_r},{s_r},{v_r})")
                start = time.time()
                while time.time() - start < 0.7:
                    set_motor_power_safe(left_motor, right_motor, 0, 100)
                    time.sleep(0.05)
                print("[ADJUST] Turning RIGHT adjust")
                set_motor_power_safe(left_motor, right_motor, 100, 30)
                time.sleep(1.0)
                return
        else:
            if left_is_green or right_is_green:
                print(f"[IGNORE GREEN] L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r})")

        # --- ???????? ---
        if left_is_black and not right_is_black:
            set_motor_power_safe(left_motor, right_motor, 30, 70)
            last_direction = "LEFT"
        elif right_is_black and not left_is_black:
            set_motor_power_safe(left_motor, right_motor, 70, 30)
            last_direction = "RIGHT"
        elif not left_is_black and not right_is_black:
            print("[NO BLACK] ?????")
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"

        # --- ?????1???? ---
        if current_time - last_log_time > 1.0:
            print(f"HSV L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r}) | Dir={last_direction}")
            last_log_time = current_time

    except Exception as e:
        print(f"[ERROR] {e}")

# === ?? ===
(ETRobo(backend='raspike_art')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='A')
 .add_device('color_sensor_left', device_type=ColorSensor, port='D')
 .add_device('color_sensor_right', device_type=ColorSensor, port='C')
 .add_handler(trace_with_green_turn)
 .dispatch(interval=0.2, port='/dev/ttyACM0'))
</code></pre>
      </div>

      <div class="desc-box">
  <h3>(プログラムの説明)</h3>

  <p>
    このプログラムは、左右のカラーセンサーから取得した <strong>RGB値</strong> を  
    <strong>HSV色空間</strong> に変換し、緑色を検出した側に応じて左折・右折動作を行う制御処理です。  
    緑を検出しない場合は黒ラインを認識してライントレースを行い、直進・左右補正を切り替えます。  
    <strong>ETRobo（Raspberry Pi）環境</strong>で動作し、モーターとカラーセンサーをPythonから制御します。
  </p>

  <h4>① ライブラリと変数の準備</h4>
  <p>
    OpenCV / NumPy / ETRobo の各ライブラリを読み込み、  
    モーター出力やログ制御に使用するグローバル変数を初期化しています。  
    <code>ignore_green_until</code> は交差点検知後に「緑を一時的に無視するためのタイマー」です。
  </p>

  <h4>② RGB ⇒ HSV 変換関数</h4>
  <p>
    カラーセンサーの取得値（RGB）を OpenCV によって HSV へ変換します。  
    HSVは色情報（特に緑・黒）を数値的に判定しやすいため、色処理に適しています。
  </p>

  <h4>③ 緑色判定関数</h4>
  <p>
    Hue が <strong>75〜100</strong> の範囲で、明度が高い場合に「緑色」として判定します。  
    これは交差点の緑マーカー検知に使用されます。
  </p>

  <h4>④ 黒色判定（ライン検出）</h4>
  <p>
    彩度が低く、明度も低い場合を「黒」と判定し、ラインの位置を認識します。  
    左と右の黒検知状況からロボットの角度補正を行います。
  </p>

  <h4>⑤ モーターの安全セット関数</h4>
  <p>
    毎回 set_power を連続で呼ぶと不安定な動作になるため、  
    <strong>前回の出力と異なる場合のみ</strong> モーターに値を送る安全制御となっています。
  </p>

  <h4>⑥ メイン処理：ライントレース＋緑分岐</h4>

  <h5>⑥-1 センサー読み取り</h5>
  <p>
    各ループごとに左右カラーセンサーの HSV 値を取得します。
  </p>

  <h5>⑥-2 緑・黒の判定</h5>
  <p>
    左右のセンサーそれぞれについて、  
    ・緑 → 交差点分岐用  
    ・黒 → ライントレース用  
    として判定しています。
  </p>

  <h5>⑥-3 黒が両方 → 交差点として直進＋緑無視</h5>
  <p>
    左右どちらも黒の場合 <strong>十字路の中央</strong> と判断します。  
    このとき緑が誤検知されやすいため、  
    <strong>0.8秒間は緑検知を無視するタイマー</strong> を設定します。
  </p>

  <h5>⑥-4 緑による分岐（無視時間が終わった後）</h5>
  <p>
    緑無視タイマーが終了したら、  
    ・左緑 → 左折  
    ・右緑 → 右折  
    の分岐処理を行います。
  </p>

  <p>
    左折・右折処理では、  
    ・まずモーターの左右出力を変えて回頭  
    ・その後、姿勢補正のための微調整  
    を行う2段階方式で曲がります。
  </p>

  <p>
    無視時間中に緑が見えても、「無視した」ログを出すだけで処理しません。
  </p>

  <h5>⑥-5 ライントレース制御（緑なし）</h5>
  <p>
    ・左が黒 → ラインは左 → 左方向へ補正  
    ・右が黒 → ラインは右 → 右方向へ補正  
    ・どちらも黒でない → ラインが見えない → とりあえず直進  
  </p>

  <h5>⑥-6 ログの出力</h5>
  <p>
    ログが多くなりすぎないように、  
    <strong>1秒に1回だけ</strong> センサー値や方向を出力します。
  </p>

  <h4>⑦ ETRobo 設定と dispatch</h4>
  <p>
    ETRobo デバイス（モーター・カラーセンサー）を登録し、  
    <strong>0.2秒ごとに trace_with_green_turn を実行するよう dispatch</strong> しています。
  </p>

</div>

        <video controls>
      <source src="midori_u.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑の交差点を検知して、進行方向を判断するロボットの動画です。
    </div>


        <h2>midori_u.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code>import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

last_direction = "STRAIGHT"
prev_left_power = -1
prev_right_power = -1
last_log_time = 0

# ?????HSV?3?????????
def get_stable_hsv(sensor: ColorSensor, samples=10, delay=0.02):
    h_list, s_list, v_list = [], [], []
    for _ in range(samples):
        r, g, b = sensor.get_raw_color()
        rgb = np.uint8([[[r, g, b]]])
        hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)[0][0]
        h_list.append(hsv[0])
        s_list.append(hsv[1])
        v_list.append(hsv[2])
        time.sleep(delay)
    return int(np.mean(h_list)), int(np.mean(s_list)), int(np.mean(v_list))

# ?????S=0 ???? >=60 / V >=160?
def is_green(h, s, v):
    return (75 <= h <= 100) and (s == 0 or s >= 60) and v >= 160

# ???????????????
def is_black(s, v):
    return s < 100 and v < 80

# ???????????????
def set_motor_power_safe(left_motor, right_motor, lp, rp):
    global prev_left_power, prev_right_power
    if lp != prev_left_power:
        left_motor.set_power(lp)
        prev_left_power = lp
    if rp != prev_right_power:
        right_motor.set_power(rp)
        prev_right_power = rp
# ????????????????????
def trace_with_green_turn(right_motor: Motor, left_motor: Motor,
                          color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction, last_log_time

    try:
        h_l, s_l, v_l = get_stable_hsv(color_sensor_left)
        h_r, s_r, v_r = get_stable_hsv(color_sensor_right)

        left_is_green = is_green(h_l, s_l, v_l)
        right_is_green = is_green(h_r, s_r, v_r)

        left_is_black = is_black(s_l, v_l)
        right_is_black = is_black(s_r, v_r)

        current_time = time.time()

        # === ????U????===
        if left_is_green and right_is_green:
            print(f"[U-TURN] ???: L=({h_l},{s_l},{v_l}) R=({h_r},{s_r},{v_r})")
            start = time.time()
            while time.time() - start < 0.7:
                set_motor_power_safe(left_motor, right_motor, 100, -100)
                time.sleep(18.0)
            print("[U-TURN COMPLETE]")
            return

        # === ?????????===
        elif left_is_green and not left_is_black:
            print(f"[LEFT TURN] ?: L=({h_l},{s_l},{v_l})")
            start = time.time()
            while time.time() - start < 0.7:
                set_motor_power_safe(left_motor, right_motor, 100, 0)
                time.sleep(1.5)
            print("[ADJUST] ???? ??")
            set_motor_power_safe(left_motor, right_motor, 30, 100)
            time.sleep(1.0)
            return

        # === ?????????===
        elif right_is_green and not right_is_black:
            print(f"[RIGHT TURN] ?: R=({h_r},{s_r},{v_r})")
            start = time.time()
            while time.time() - start < 0.7:
                set_motor_power_safe(left_motor, right_motor, 0, 100)
                time.sleep(1.5)
            print("[ADJUST] ???? ??")
            set_motor_power_safe(left_motor, right_motor, 100, 30)
            time.sleep(1.0)
            return

        # === ??????????===
        if left_is_black and not right_is_black:
            set_motor_power_safe(left_motor, right_motor, 30, 70)
            last_direction = "LEFT"
        elif right_is_black and not left_is_black:
            set_motor_power_safe(left_motor, right_motor, 70, 30)
            last_direction = "RIGHT"
        elif left_is_black and right_is_black:
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"
        else:
            # ????????????
            print("[NO BLACK] ?????????????")
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"

        # === ???1????===
        if current_time - last_log_time > 1.0:
            print(f"HSV L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r}) | Dir={last_direction}")
            last_log_time = current_time

    except Exception as e:
        print(f"[ERROR] {e}")

# === ????????????????===
(ETRobo(backend='raspike_art')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='A')
 .add_device('color_sensor_left', device_type=ColorSensor, port='D')
 .add_device('color_sensor_right', device_type=ColorSensor, port='C')
 .add_handler(trace_with_green_turn)
 .dispatch(interval=0.2, port='/dev/ttyACM0'))

</code></pre>
      </div>

      <div class="desc-box">
        <h3>(プログラムの説明)</h3>
        <p><b>1️⃣ 緑検知：</b> HSV色空間で緑色の範囲を抽出し、交差点位置を検出します。</p>
        <p><b>2️⃣ 動作判断：</b> 緑を見つけたら右折動作を実行し、方向転換を行います。</p>
        <p><b>3️⃣ 通常走行：</b> 緑が見つからない場合は白黒ラインの追従を続けます。</p>
      </div>
    </div>



            <video controls>
      <source src="midori_hidari.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑の交差点を検知して、進行方向を判断するロボットの動画です。
    </div>


        <h2>midori_hidari.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code>import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

last_direction = "RIGHT"  # ?????????

def get_hsv_from_sensor(sensor: ColorSensor):
    r, g, b = sensor.get_raw_color()
    rgb = np.uint8([[[r, g, b]]])
    hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)
    return hsv[0][0]

def is_green(h, s, v):
    return (75 <= h <= 100) and (s == 0 or s >= 150) and v >= 160

def trace_and_turn_on_green(right_motor: Motor, left_motor: Motor,
                            color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction
    try:
        h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
        h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)

        left_is_green = is_green(h_l, s_l, v_l)
        right_is_green = is_green(h_r, s_r, v_r)

        # === ?????? ? ???? ===
        if left_is_green and right_is_green:
            print(f"[STOP] BOTH GREEN: L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r})")
            left_motor.set_power(0)
            right_motor.set_power(0)

            # ?????????
            while True:
                h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
                h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)
                if not (is_green(h_l, s_l, v_l) and is_green(h_r, s_r, v_r)):
                    print("[RESUME] Green cleared. Resuming motion.")
                    break
                time.sleep(0.1)
            return

        # === ???????? ===
        if left_is_green:
            print(f"[LEFT TURN] LEFT GREEN. HSV=({h_l},{s_l},{v_l})")
            start_time = time.time()
            while time.time() - start_time < 8.5:
                left_motor.set_power(100)
                right_motor.set_power(0)
                time.sleep(0.05)
            return

        if right_is_green:
            print(f"[RIGHT TURN] RIGHT GREEN. HSV=({h_r},{s_r},{v_r})")
            start_time = time.time()
            while time.time() - start_time < 8.5:
                left_motor.set_power(0)
                right_motor.set_power(100)
                time.sleep(0.05)
            return

        # === ?????????? ===
        if v_l < 60 and s_l < 100:
            power = 30
            left_motor.set_power(power)
            right_motor.set_power(power)
            last_direction = "STRAIGHT"
        else:
            if last_direction in ["STRAIGHT", "RIGHT"]:
                left_motor.set_power(60)
                right_motor.set_power(0)
                last_direction = "LEFT"
            else:
                left_motor.set_power(0)
                right_motor.set_power(60)
                last_direction = "RIGHT"

        print(f"HSV L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r}) | Dir={last_direction}")

    except Exception as e:
        print(f"[ERROR] {e}")

# === ???? ===
(ETRobo(backend='raspike_art')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='A')
 .add_device('color_sensor_left', device_type=ColorSensor, port='D')
 .add_device('color_sensor_right', device_type=ColorSensor, port='C')
 .add_handler(trace_and_turn_on_green)
 .dispatch(interval=0.1, port='/dev/ttyACM0'))
</code></pre>
      </div>

      <div class="desc-box">
        <h3>(プログラムの説明)</h3>
        <p><b>1️⃣ 緑検知：</b> HSV色空間で緑色の範囲を抽出し、交差点位置を検出します。</p>
        <p><b>2️⃣ 動作判断：</b> 緑を見つけたら右折動作を実行し、方向転換を行います。</p>
        <p><b>3️⃣ 通常走行：</b> 緑が見つからない場合は白黒ラインの追従を続けます。</p>
      </div>
    </div>


    <!-- ▼ 学習のやり方セクション ▼ -->
    <div class="learn-section">
      <h2>📘 学習のやり方</h2>
      <p>交差点付きライントレースの学習では、次の手順で練習を進めましょう。</p>
      <ol class="learn-list">
        <li><b>緑検知の確認：</b> 緑のテープを設置し、カメラが正確に認識できるか確認します。</li>
        <li><b>動作テスト：</b> 緑を検出した際に右折・左折など正しい動作ができるか試します。</li>
        <li><b>判定調整：</b> 照明やカメラの角度によって認識精度が変化するため、閾値を微調整します。</li>
        <li><b>応用練習：</b> 複数の交差点を設置して、連続的な判断と制御を試みましょう。</li>
      </ol>
      <p>緑のマーカーを「指示信号」として扱うことで、より高度な自律走行制御に近づけます。</p>
    </div>

  </main>

</body>
</html>
