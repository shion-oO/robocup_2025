<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>交差点付きライントレース</title>
  <style>
    body {
      font-family: 'Helvetica Neue', sans-serif;
      background-color: #f0f4f8;
      margin: 0;
      padding: 0;
      color: #2c3e50;
    }

    header {
      background-color: #3498db;
      color: white;
      padding: 20px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: 2em;
    }

    nav {
      background-color: #ecf0f1;
      padding: 10px 20px;
      text-align: center;
    }

    nav a {
      color: #3498db;
      text-decoration: none;
      margin: 0 15px;
      font-weight: bold;
    }

    nav a:hover {
      text-decoration: underline;
    }

    main {
      padding: 40px 20px;
      max-width: 1200px;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    video {
      width: 100%;
      max-width: 640px;
      border-radius: 10px;
      display: block;
      margin: 0 auto;
    }

    .caption {
      margin-top: 12px;
      font-size: 16px;
      color: #444;
      text-align: center;
      margin-bottom: 60px;
    }

    h2 {
      color: #3498db;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
      margin-top: 40px;
    }

    .code-section {
      display: flex;
      gap: 30px;
      margin-top: 30px;
      margin-bottom: 70px;
      flex-wrap: wrap;
    }

    .code-box {
      flex: 1;
      min-width: 480px;
      background: #f7f9fb;
      border-radius: 10px;
      padding: 25px;
      overflow-x: auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    pre {
      margin: 0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
      color: #333;
    }

    .desc-box {
      flex: 1;
      min-width: 400px;
      background: #eaf4fc;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .desc-box p {
      margin-bottom: 10px;
      line-height: 1.6;
    }

    /* ▼ 学習セクション ▼ */
    .learn-section {
      margin-top: 60px;
      background-color: #f7f9fb;
      padding: 40px 30px;
      border-radius: 10px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.1);
    }

    .learn-section h2 {
      text-align: center;
      font-size: 1.8em;
      color: #3498db;
      border-bottom: none;
      margin-bottom: 20px;
    }

    .learn-section p {
      font-size: 1.1em;
      line-height: 1.8;
      color: #2c3e50;
      margin-bottom: 15px;
    }

    .learn-list {
      list-style: decimal;
      padding-left: 25px;
      font-size: 1.05em;
      line-height: 1.8;
    }

  </style>
</head>
<body>

  <header>
    <h1>交差点付きライントレース</h1>
  </header>

  <nav>
    <a href="robocup_home.html">ホーム</a>
    <a href="linetrace.html">白黒ライントレース</a>
    <a href="linetrace3.html">ギャップライントレース</a>
    <a href="goal.html">ゴールタイル</a>
  </nav>

  <main>
    <video controls>
      <source src="midori_kenti.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑を検知して、進行方向を判断するロボットの動画です。
    </div>

    <h2>midori_kenti.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code># ① ライブラリのインポート
import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

# ② グローバル変数
last_direction = "RIGHT"

# ③ HSV変換関数
def get_hsv_from_sensor(sensor: ColorSensor):
    r, g, b = sensor.get_raw_color()
    rgb = np.uint8([[[r, g, b]]])
    hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)
    return hsv[0][0]

# ④ 緑色検知関数（左・右）
def is_green_left(h, s, v):
    return (70 <= h <= 90) and (13 <= s <= 30) and (25 <= v <= 35)

def is_green_right(h, s, v):
    return (75 <= h <= 80) and (120 <= s <= 150) and (35 <= v <= 50)

# ⑤ メイン制御関数
def trace_and_turn_on_green(right_motor: Motor, left_motor: Motor,
                            color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction
    try:
        h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
        h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)

        left_is_green = is_green_left(h_l, s_l, v_l)
        right_is_green = is_green_right(h_r, s_r, v_r)

        if left_is_green:
            print(f"[LEFT TURN] Green detected on LEFT sensor (HSV={h_l},{s_l},{v_l})")
            left_motor.set_power(50)
            right_motor.set_power(0)
            time.sleep(1.5)  
            return

        if right_is_green:
            print(f"[RIGHT TURN] Green detected on RIGHT sensor (HSV={h_r},{s_r},{v_r})")
            left_motor.set_power(0)
            right_motor.set_power(50)
            time.sleep(1.5)
            return

        if v_l < 60 and s_l < 100:
            power = 30
            left_motor.set_power(power)
            right_motor.set_power(power)
            last_direction = "STRAIGHT"
        else:
            if last_direction in ["STRAIGHT", "RIGHT"]:
                left_motor.set_power(50)
                right_motor.set_power(0)
                last_direction = "LEFT"
            else:
                left_motor.set_power(0)
                right_motor.set_power(50)
                last_direction = "RIGHT"

        print(f"LEFT HSV=({h_l},{s_l},{v_l}) | RIGHT HSV=({h_r},{s_r},{v_r}) | Dir={last_direction}")

    except Exception as e:
        print(f"[ERROR] {e}")

# ⑥ 実行部分
(ETRobo(backend='raspyke')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='C')
 .add_device('color_sensor_left', device_type=ColorSensor, port='S2')
 .add_device('color_sensor_right', device_type=ColorSensor, port='S3')
 .add_handler(trace_and_turn_on_green)
 .dispatch(interval=0.1))
</code></pre>
      </div>

<div class="desc-box">
  <h3>(プログラムの説明)</h3>

  <p>
    このプログラムは、左右のカラーセンサーで取得した<strong>RGB値</strong>を<strong>HSV色空間</strong>に変換し、  
    緑色を検出した側に合わせて右折・左折を行うように制御します。  
    緑が検出されないときはラインをトレースして直進または補正走行を行います。  
    <strong>eTRobo環境</strong>で実行され、モーター・センサーは<strong>Raspberry Pi</strong>経由で制御されます。
  </p>

  <h4>① ライブラリのインポート</h4>
  <p>
    画像処理ライブラリ（<code>cv2</code>, <code>numpy</code>）と、  
    ETロボコン用デバイス制御ライブラリ（<code>etrobo_python</code>）を読み込んでいます。  
    これにより、ロボットのモーターやカラーセンサーをPythonから操作できるようになります。
  </p>

  <h4>② グローバル変数</h4>
  <p>
    ロボットが<strong>直前にどちらへ進んだか（右・左・直進）</strong>を記録しておくための変数です。  
    次の動作を決める際に参照されます。
  </p>

  <h4>③ HSV変換関数</h4>
  <p>
    センサーから取得したRGB値を、色検出に適した<strong>HSV形式</strong>に変換します。  
    HSVは「色相（Hue）」「彩度（Saturation）」「明度（Value）」を表し、  
    緑色などの判定を安定して行えるようになります。
  </p>

  <h4>④ 緑色検知関数（左・右）</h4>
  <p>
    左右のカラーセンサーで取得したHSV値が、  
    あらかじめ設定された「緑色の範囲」に入っているかを判定します。  
    左右で条件を少し変えているのは、照明環境やセンサー個体差を補正するためです。
  </p>

  <h4>⑤ メイン制御関数</h4>
  <p>
    この関数がロボット走行の中心となる処理です。
  </p>
  <ol>
    <li>HSV値を取得し、左右のカラーセンサーから色データを読み取る。</li>
    <li>緑色が左にあれば左折、右にあれば右折を行う。</li>
    <li>緑がない場合はライントレース（前進・微調整）を行う。</li>
    <li>最後にどちらへ曲がったかを記録し、次回の補正に利用。</li>
  </ol>

  <h4>⑥ 実行部分</h4>
  <p>
    ロボット本体を初期化し、モーターやセンサーを登録します。  
    <code>dispatch(interval=0.1)</code> により、0.1秒ごとに上記の制御関数を繰り返し実行します。
  </p>
</div>


<div class="tips-section">
  <h2>よくある問題と改善のヒント</h2>
  <div class="tips-grid">

    <article class="desc-box">
      <h3>🚦 緑が正しく検知されない</h3>
      <p>・左右で緑のHSV範囲が違いすぎる<br>・明るさや照明で検知値が変わる<br>・<code>is_green_left</code> と <code>is_green_right</code> の範囲を調整</p>
      <p style="color:#16a34a; font-weight:600;">🌱 HSVの範囲を見直そう！</p>
    </article>

    <article class="desc-box">
      <h3>🕹️ 左右の動きが不安定</h3>
      <p>・モーター出力が固定で補正がない<br>・ラインを見失ったときの制御が弱い<br>・前回方向（<code>last_direction</code>）の扱いを改善</p>
      <p style="color:#2b7bd3; font-weight:600;">⚙️ 前回方向で補正！</p>
    </article>

    <article class="desc-box">
      <h3>🖤 黒ラインが正しく認識されない</h3>
      <p>・明度Vと彩度Sの閾値が適切でない<br>・周囲の明るさや影で誤判定<br>・<code>v_l < 60 and s_l < 100</code> を環境に合わせて調整</p>
      <p style="color:#16a34a; font-weight:600;">🎨 閾値を環境に合わせよう！</p>
    </article>

    <article class="desc-box">
      <h3>↔️ 左右が逆になる／旋回方向がおかしい</h3>
      <p>・モーター接続ポート（A/B）が逆<br>・コードで左右モーター出力の割り当てを確認<br>・センサー配線と方向を確認</p>
      <p style="color:#2b7bd3; font-weight:600;">🧭 モーターとセンサー接続をチェック！</p>
    </article>

    <article class="desc-box">
      <h3>⏱️ 緑検知後の旋回時間が長すぎる／短すぎる</h3>
      <p>・<code>time.sleep(1.5)</code> の値を環境や旋回速度に合わせる<br>・モーター出力と時間のバランスを確認</p>
      <p style="color:#16a34a; font-weight:600;">⏳ 旋回時間を微調整！</p>
    </article>

  </div>
</div>


        <video controls>
      <source src="midori_tyokusin.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑の交差点を検知して、進行方向を判断するロボットの動画です。
    </div>

        <h2>midori_tyokusin.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code>
# ① ライブラリと変数の準備
import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

last_direction = "STRAIGHT"
prev_left_power = -1
prev_right_power = -1
last_log_time = 0
ignore_green_until = 0  

# ② RGB ⇒ HSV 変換関数
def get_hsv_from_sensor(sensor: ColorSensor):
    r, g, b = sensor.get_raw_color()
    rgb = np.uint8([[[r, g, b]]])
    hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)
    return hsv[0][0]

# ③ 緑色判定関数
def is_green(h, s, v):
    return (75 <= h <= 100) and (s == 0 or s >= 60) and v >= 160

# ④ 黒色判定（ライン）
def is_black(s, v):
    return s < 100 and v < 80

# ⑤ モーターの安全セット関数
def set_motor_power_safe(left_motor, right_motor, lp, rp):
    global prev_left_power, prev_right_power
    if lp != prev_left_power:
        left_motor.set_power(lp)
        prev_left_power = lp
    if rp != prev_right_power:
        right_motor.set_power(rp)
        prev_right_power = rp

# ⑥ メイン処理：ライントレース＋緑分岐
def trace_with_green_turn(right_motor: Motor, left_motor: Motor,
                          color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction, last_log_time, ignore_green_until

    # ⑥-1 センサー読み取り
    try:
        h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
        h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)

        # ⑥-2 緑・黒の判定
        left_is_green = is_green(h_l, s_l, v_l)
        right_is_green = is_green(h_r, s_r, v_r)

        left_is_black = is_black(s_l, v_l)
        right_is_black = is_black(s_r, v_r)

        current_time = time.time()

        # ⑥-3 黒が両方 → 交差点として直進＋緑無視
        if left_is_black and right_is_black:
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"
            ignore_green_until = current_time + 0.8  
            print("[CROSS] BOTH BLACK ? GO STRAIGHT & IGNORE GREEN")
            return
            # ⑥-4 緑による分岐（無視時間が終わった後）
        if current_time > ignore_green_until:
            if left_is_green and not left_is_black:
                print(f"[LEFT TURN] GREEN DETECTED: L=({h_l},{s_l},{v_l})")
                start = time.time()
                while time.time() - start < 0.7:
                    set_motor_power_safe(left_motor, right_motor, 100, 0)
                    time.sleep(0.05)
                print("[ADJUST] Turning LEFT adjust")
                set_motor_power_safe(left_motor, right_motor, 30, 100)
                time.sleep(1.0)
                return

            if right_is_green and not right_is_black:
                print(f"[RIGHT TURN] GREEN DETECTED: R=({h_r},{s_r},{v_r})")
                start = time.time()
                while time.time() - start < 0.7:
                    set_motor_power_safe(left_motor, right_motor, 0, 100)
                    time.sleep(0.05)
                print("[ADJUST] Turning RIGHT adjust")
                set_motor_power_safe(left_motor, right_motor, 100, 30)
                time.sleep(1.0)
                return
        else:
            if left_is_green or right_is_green:
                print(f"[IGNORE GREEN] L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r})")

        # ⑥-5 ライントレース制御（緑なし）
        if left_is_black and not right_is_black:
            set_motor_power_safe(left_motor, right_motor, 30, 70)
            last_direction = "LEFT"
        elif right_is_black and not left_is_black:
            set_motor_power_safe(left_motor, right_motor, 70, 30)
            last_direction = "RIGHT"
        elif not left_is_black and not right_is_black:
            print("[NO BLACK] ?????")
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"

        # ⑥-6 ログの出力
        if current_time - last_log_time > 1.0:
            print(f"HSV L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r}) | Dir={last_direction}")
            last_log_time = current_time

    except Exception as e:
        print(f"[ERROR] {e}")

# ⑦ ETRobo 設定と dispatch
(ETRobo(backend='raspike_art')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='A')
 .add_device('color_sensor_left', device_type=ColorSensor, port='D')
 .add_device('color_sensor_right', device_type=ColorSensor, port='C')
 .add_handler(trace_with_green_turn)
 .dispatch(interval=0.2, port='/dev/ttyACM0'))
</code></pre>
      </div>

      <div class="desc-box">
  <h3>(プログラムの説明)</h3>

  <h4>① ライブラリと変数の準備</h4>
  <p>
    OpenCV / NumPy / ETRobo の各ライブラリを読み込み、  
    モーター出力やログ制御に使用するグローバル変数を初期化しています。  
    <code>ignore_green_until</code> は交差点検知後に「緑を一時的に無視するためのタイマー」です。
  </p>

  <h4>② RGB ⇒ HSV 変換関数</h4>
  <p>
    カラーセンサーの取得値（RGB）を OpenCV によって HSV へ変換します。  
    HSVは色情報（特に緑・黒）を数値的に判定しやすいため、色処理に適しています。
  </p>

  <h4>③ 緑色判定関数</h4>
  <p>
    Hue が <strong>75〜100</strong> の範囲で、明度が高い場合に「緑色」として判定します。  
    これは交差点の緑マーカー検知に使用されます。
  </p>

  <h4>④ 黒色判定（ライン検出）</h4>
  <p>
    彩度が低く、明度も低い場合を「黒」と判定し、ラインの位置を認識します。  
    左と右の黒検知状況からロボットの角度補正を行います。
  </p>

  <h4>⑤ モーターの安全セット関数</h4>
  <p>
    毎回 set_power を連続で呼ぶと不安定な動作になるため、  
    <strong>前回の出力と異なる場合のみ</strong> モーターに値を送る安全制御となっています。
  </p>

  <h4>⑥ メイン処理：ライントレース＋緑分岐</h4>

  <h5>⑥-1 センサー読み取り</h5>
  <p>
    各ループごとに左右カラーセンサーの HSV 値を取得します。
  </p>

  <h5>⑥-2 緑・黒の判定</h5>
  <p>
    左右のセンサーそれぞれについて、  
    ・緑 → 交差点分岐用  
    ・黒 → ライントレース用  
    として判定しています。
  </p>

  <h5>⑥-3 黒が両方 → 交差点として直進＋緑無視</h5>
  <p>
    左右どちらも黒の場合 <strong>十字路の中央</strong> と判断します。  
    このとき緑が誤検知されやすいため、  
    <strong>0.8秒間は緑検知を無視するタイマー</strong> を設定します。
  </p>

  <h5>⑥-4 緑による分岐（無視時間が終わった後）</h5>
  <p>
    緑無視タイマーが終了したら、  
    ・左緑 → 左折  
    ・右緑 → 右折  
    の分岐処理を行います。
  </p>

  <p>
    左折・右折処理では、  
    ・まずモーターの左右出力を変えて回頭  
    ・その後、姿勢補正のための微調整  
    を行う2段階方式で曲がります。
  </p>

  <p>
    無視時間中に緑が見えても、「無視した」ログを出すだけで処理しません。
  </p>

  <h5>⑥-5 ライントレース制御（緑なし）</h5>
  <p>
    ・左が黒 → ラインは左 → 左方向へ補正  
    ・右が黒 → ラインは右 → 右方向へ補正  
    ・どちらも黒でない → ラインが見えない → とりあえず直進  
  </p>

  <h5>⑥-6 ログの出力</h5>
  <p>
    ログが多くなりすぎないように、  
    <strong>1秒に1回だけ</strong> センサー値や方向を出力します。
  </p>

  <h4>⑦ ETRobo 設定と dispatch</h4>
  <p>
    ETRobo デバイス（モーター・カラーセンサー）を登録し、  
    <strong>0.2秒ごとに trace_with_green_turn を実行するよう dispatch</strong> しています。
  </p>

</div>

        <video controls>
      <source src="midori_u.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑の交差点を検知して、進行方向を判断するロボットの動画です。
    </div>


        <h2>midori_u.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code>import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

last_direction = "STRAIGHT"
prev_left_power = -1
prev_right_power = -1
last_log_time = 0

#  ① 安定したHSV値を取得 
def get_stable_hsv(sensor: ColorSensor, samples=10, delay=0.02):
    h_list, s_list, v_list = [], [], []
    for _ in range(samples):
        r, g, b = sensor.get_raw_color()
        rgb = np.uint8([[[r, g, b]]])
        hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)[0][0]
        h_list.append(hsv[0])
        s_list.append(hsv[1])
        v_list.append(hsv[2])
        time.sleep(delay)
    return int(np.mean(h_list)), int(np.mean(s_list)), int(np.mean(v_list))

# ② 緑色判定 
def is_green(h, s, v):
    return (75 <= h <= 100) and (s == 0 or s >= 60) and v >= 160

# ③ 黒判定 
def is_black(s, v):
    return s < 100 and v < 80

# ④ モーター出力を安全に設定 
def set_motor_power_safe(left_motor, right_motor, lp, rp):
    global prev_left_power, prev_right_power
    if lp != prev_left_power:
        left_motor.set_power(lp)
        prev_left_power = lp
    if rp != prev_right_power:
        right_motor.set_power(rp)
        prev_right_power = rp

def trace_with_green_turn(right_motor: Motor, left_motor: Motor,
                          color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction, last_log_time

    ⑤ 左右のHSV取得 ＋ 色判定（緑 / 黒）
    try:
        h_l, s_l, v_l = get_stable_hsv(color_sensor_left)
        h_r, s_r, v_r = get_stable_hsv(color_sensor_right)

        left_is_green = is_green(h_l, s_l, v_l)
        right_is_green = is_green(h_r, s_r, v_r)

        left_is_black = is_black(s_l, v_l)
        right_is_black = is_black(s_r, v_r)

        current_time = time.time()
        
        # ⑥ 緑による分岐動作（Uターン／左折／右折）
        # ⑥-1 左右とも緑 → Uターン
        if left_is_green and right_is_green:
            print(f"[U-TURN] ???: L=({h_l},{s_l},{v_l}) R=({h_r},{s_r},{v_r})")
            start = time.time()
            while time.time() - start < 0.7:
                set_motor_power_safe(left_motor, right_motor, 100, -100)
                time.sleep(18.0)
            print("[U-TURN COMPLETE]")
            return

        # ⑥-2 左だけ緑 → 左折
        elif left_is_green and not left_is_black:
            print(f"[LEFT TURN] ?: L=({h_l},{s_l},{v_l})")
            start = time.time()
            while time.time() - start < 0.7:
                set_motor_power_safe(left_motor, right_motor, 100, 0)
                time.sleep(1.5)
            print("[ADJUST] ???? ??")
            set_motor_power_safe(left_motor, right_motor, 30, 100)
            time.sleep(1.0)
            return

        # ⑥-3 右だけ緑 → 右折
        elif right_is_green and not right_is_black:
            print(f"[RIGHT TURN] ?: R=({h_r},{s_r},{v_r})")
            start = time.time()
            while time.time() - start < 0.7:
                set_motor_power_safe(left_motor, right_motor, 0, 100)
                time.sleep(1.5)
            print("[ADJUST] ???? ??")
            set_motor_power_safe(left_motor, right_motor, 100, 30)
            time.sleep(1.0)
            return

        #  ⑦ 黒によるライントレース制御
        if left_is_black and not right_is_black:
            set_motor_power_safe(left_motor, right_motor, 30, 70)
            last_direction = "LEFT"
        elif right_is_black and not left_is_black:
            set_motor_power_safe(left_motor, right_motor, 70, 30)
            last_direction = "RIGHT"
        elif left_is_black and right_is_black:
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"
        else:
            # ????????????
            print("[NO BLACK] ?????????????")
            set_motor_power_safe(left_motor, right_motor, 60, 60)
            last_direction = "STRAIGHT"

        # ⑧ 1秒ごとのログ出力
        if current_time - last_log_time > 1.0:
            print(f"HSV L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r}) | Dir={last_direction}")
            last_log_time = current_time

    except Exception as e:
        print(f"[ERROR] {e}")

# ⑨ ETRobo の設定と実行開始
(ETRobo(backend='raspike_art')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='A')
 .add_device('color_sensor_left', device_type=ColorSensor, port='D')
 .add_device('color_sensor_right', device_type=ColorSensor, port='C')
 .add_handler(trace_with_green_turn)
 .dispatch(interval=0.2, port='/dev/ttyACM0'))

</code></pre>
      </div>

      <div class="desc-box">
  <h3>① 安定した HSV 値を取得する処理（get_stable_hsv）</h3>
  <p>
    この関数では、カラーセンサーから取得した RGB 値を複数回（デフォルト10回）読み取り、平均化することで
    <b>安定した HSV 値</b> を作っています。<br><br>
    センサーの値は環境光や揺れによって誤差が大きくなるため、1回だけでは信頼できません。
    そのため、RGB → HSV 変換を10回行い、各値の平均を返すようにしています。
  </p>

  <h3>② 緑色の判定（is_green）</h3>
  <p>
    この条件では、主に以下の特徴を持つものを緑色として判定します。<br>
    ・H（色相）が 75〜100<br>
    ・S（彩度）が 0（センサー特性の例外）または 60以上<br>
    ・V（明度）が 160以上<br><br>
    明確な緑色だけを検出するための条件になっています。
  </p>

  <h3>③ 黒色（ライン）の判定（is_black）</h3>
  <p>
    黒いラインは明るさ（V）が低く、彩度（S）も低いという特徴を持っています。<br><br>
    そのため、<br>
    ・S &lt; 100<br>
    ・V &lt; 80<br><br>
    という条件で黒ラインを検出しています。ライントレース制御の基礎となる部分です。
  </p>

  <h3>④ モーター出力を安全に設定する仕組み（set_motor_power_safe）</h3>
  <p>
    ETRobo では、短い周期で頻繁に set_power() を繰り返すと不安定さが生じる場合があります。<br><br>
    そのため、この関数では <b>前回と異なる値のときだけ set_power を実行</b> しています。<br><br>
    これにより、<br>
    ・ロボットの急な揺れや振動の防止<br>
    ・モーター制御の安定化<br>
    ・不必要な通信の削減<br>
    といった効果があります。
  </p>

  <h3>⑤ 左右のカラーセンサーから HSV を取得して色を判定する処理</h3>
  <p>
    メインループの先頭では、<br>
    ・左センサーの HSV<br>
    ・右センサーの HSV<br><br>
    を安定した値として取得し、<br>
    ・左右の緑判定<br>
    ・左右の黒判定<br><br>
    を行います。これらの判定結果に応じて、方向転換やライントレース動作が決まっていきます。
  </p>

  <h3>⑥ 緑による分岐動作（Uターン・左折・右折）</h3>

  <h4>⑥-1 左右とも緑 → Uターン</h4>
  <p>
    左右両方のセンサーが緑を検知した場合、Uターン処理に入ります。<br>
    ・左モーター：前進<br>
    ・右モーター：後退<br>
    ・約0.7秒間その場回転<br><br>
    この処理で確実に反転します。
  </p>

  <h4>⑥-2 左だけ緑 → 左折</h4>
  <p>
    左センサーが緑を検出した場合、左折動作を行います。<br>
    ・左モーターを強く<br>
    ・右モーターを止める<br><br>
    ことで左回転し、その後ラインへ戻るための補正（左30 / 右100）を行います。
  </p>

  <h4>⑥-3 右だけ緑 → 右折</h4>
  <p>
    右センサーが緑を検出した場合は右折します。<br><br>
    流れは左折と同じで、<br>
    ・右側を軸に曲がる<br>
    ・曲がった後に補正を入れてラインへ復帰<br>
    という構造になっています。
  </p>

  <h3>⑦ 黒色によるライントレース制御（緑がない場合）</h3>
  <p>
    緑色が検出されない場合は通常のライントレース動作を行います。<br><br>
    ・左だけ黒 → ロボットは左寄り → 右寄せ（左30 / 右70）<br>
    ・右だけ黒 → ロボットは右寄り → 左寄せ（左70 / 右30）<br>
    ・左右両方黒 → 黒帯上 → 直進（左60 / 右60）<br>
    ・両方黒でない → ライン見失い気味 → とりあえず直進して復帰を試みる<br><br>
    このようにしてロボットはラインを追従します。
  </p>

  <h3>⑧ ログ出力（1秒ごと）</h3>
  <p>
    ログが多すぎると逆に見にくいので、<b>前回ログから1秒以上経過した場合だけ</b> 出力します。<br><br>
    出力内容：<br>
    ・左右の HSV 値<br>
    ・走行方向（LEFT / RIGHT / STRAIGHT）<br><br>
    デバッグに役立つ情報を最小限の頻度で提供しています。
  </p>

  <h3>⑨ ETRobo の設定と動作開始</h3>
  <p>
    最後に、ETRobo の環境にデバイスを登録します。<br>
    ・左右モーター（A / B）<br>
    ・左右カラーセンサー（C / D）<br><br>
    そして <b>dispatch(interval=0.2)</b> により 0.2秒周期で trace_with_green_turn が実行されます。<br>
    Raspberry Pi と ETロボコンのブロック（raspike_art）を連携させて動作させる仕組みです。
  </p>
</div>



            <video controls>
      <source src="midori_hidari.mp4" type="video/mp4">
      お使いのブラウザは動画再生に対応していません。
    </video>
    <div class="caption">
      緑の交差点を検知して、進行方向を判断するロボットの動画です。
    </div>


        <h2>midori_hidari.py</h2>
    <div class="code-section">
      <div class="code-box">
        <pre><code>import cv2
import numpy as np
from etrobo_python import ETRobo, Motor, ColorSensor
import time

last_direction = "RIGHT"  

# ① HSV値を取得する処理
def get_hsv_from_sensor(sensor: ColorSensor):
    r, g, b = sensor.get_raw_color()
    rgb = np.uint8([[[r, g, b]]])
    hsv = cv2.cvtColor(rgb, cv2.COLOR_RGB2HSV)
    return hsv[0][0]

# ② 緑色であるか判定する処理
def is_green(h, s, v):
    return (75 <= h <= 100) and (s == 0 or s >= 150) and v >= 160

def trace_and_turn_on_green(right_motor: Motor, left_motor: Motor,
                            color_sensor_left: ColorSensor, color_sensor_right: ColorSensor):
    global last_direction
    try:
        h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
        h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)

        left_is_green = is_green(h_l, s_l, v_l)
        right_is_green = is_green(h_r, s_r, v_r)

        # ③ 左右両方が緑 → 完全停止
        if left_is_green and right_is_green:
            print(f"[STOP] BOTH GREEN: L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r})")
            left_motor.set_power(0)
            right_motor.set_power(0)

            while True:
                h_l, s_l, v_l = get_hsv_from_sensor(color_sensor_left)
                h_r, s_r, v_r = get_hsv_from_sensor(color_sensor_right)
                if not (is_green(h_l, s_l, v_l) and is_green(h_r, s_r, v_r)):
                    print("[RESUME] Green cleared. Resuming motion.")
                    break
                time.sleep(0.1)
            return

        # ④ 左側だけ緑 → 左折動作に入る
        if left_is_green:
            print(f"[LEFT TURN] LEFT GREEN. HSV=({h_l},{s_l},{v_l})")
            start_time = time.time()
            while time.time() - start_time < 8.5:
                left_motor.set_power(100)
                right_motor.set_power(0)
                time.sleep(0.05)
            return

        # ⑤ 右側だけ緑 → 右折動作に入る
        if right_is_green:
            print(f"[RIGHT TURN] RIGHT GREEN. HSV=({h_r},{s_r},{v_r})")
            start_time = time.time()
            while time.time() - start_time < 8.5:
                left_motor.set_power(0)
                right_motor.set_power(100)
                time.sleep(0.05)
            return

        # ⑥ 緑が無い場合 → 黒ライン追従
        # ▼ 黒と判断（左センサー側）
        if v_l < 60 and s_l < 100:
            power = 30
            left_motor.set_power(power)
            right_motor.set_power(power)
            last_direction = "STRAIGHT"
        else:
            # ▼ 黒ではない場合は「前回の方向」をもとに補正
            if last_direction in ["STRAIGHT", "RIGHT"]:
                left_motor.set_power(60)
                right_motor.set_power(0)
                last_direction = "LEFT"
            else:
                left_motor.set_power(0)
                right_motor.set_power(60)
                last_direction = "RIGHT"

        print(f"HSV L=({h_l},{s_l},{v_l}) | R=({h_r},{s_r},{v_r}) | Dir={last_direction}")

    except Exception as e:
        print(f"[ERROR] {e}")

# ⑦ETRoboの設定と0.1秒周期ループ開始
(ETRobo(backend='raspike_art')
 .add_device('right_motor', device_type=Motor, port='B')
 .add_device('left_motor', device_type=Motor, port='A')
 .add_device('color_sensor_left', device_type=ColorSensor, port='D')
 .add_device('color_sensor_right', device_type=ColorSensor, port='C')
 .add_handler(trace_and_turn_on_green)
 .dispatch(interval=0.1, port='/dev/ttyACM0'))
</code></pre>
      </div>

      <div class="desc-box">
  <h3>プログラムの説明</h3>

  <p><b>① HSV値を取得する処理（get_hsv_from_sensor）</b><br>
  この関数では、カラーセンサーのRGB値を読み取り、OpenCVでHSVに変換しています。<br>
  RGB値をそのまま使うより色の判定が安定するため、HSV空間で色を認識するようにしています。
  </p>

  <p><b>② 緑色であるか判定する処理（is_green）</b><br>
  「75〜100の色相（H）」「彩度（S）が0または高い」「明度（V）が明るい」という特徴から、<br>
  明るい緑色を検出しています。
  </p>

  <p><b>③ 左右両方が緑 → 完全停止（STOP）</b><br>
  左右どちらのセンサーも緑を検出した場合、<br>
  交差点中央などでロボットを停止させるための動作です。<br><br>
  さらにその状態から抜けるまで緑が一定時間続く場面で勝手に動かないように安全停止しています。
  </p>

  <p><b>④ 左側だけ緑 → 左折動作に入る</b><br>
  左センサーが緑を検出したときは、<br>
  左モーターだけを回し、右を止めることで左に大きく旋回します。<br><br>
  8.5秒という長めの時間は、<br>
  大きく曲がってラインに戻る想定だと思われます。
  </p>

  <p><b>⑤ 右側だけ緑 → 右折動作に入る</b><br>
  こちらは左折の完全な反対で、<br>
  右モーターだけ動かして右旋回します。
  </p>

  <p><b>⑥ 緑が無い場合 → 黒ライン追従（または補正動作）</b><br>
  ▼ 黒と判断（左センサー側）<br>
  明度（V）が低く、彩度（S）も低い → 黒とみなし、直進方向として扱います。<br><br>

  ▼ 黒ではない場合は「前回の方向」をもとに補正<br>
  黒が見つからないときの処理です。<br>
  ・直近が右寄りなら → 左方向へ補正<br>
  ・直近が左寄りなら → 右方向へ補正<br><br>

  というように、前回の方向を覚えて補正し続ける仕組みです。<br>
  これはラインを見失ったときの自動復帰アルゴリズムとしてよく使われます。
  </p>

  <p><b>⑦ 最後にETRoboの設定と0.1秒周期ループ開始</b><br>
  この部分では、<br>
  ・モーター<br>
  ・左右のカラーセンサー<br>
  ・メイン動作関数（trace_and_turn_on_green）<br><br>
  を登録し、0.1秒（100ms）ごとに制御処理を繰り返すよう設定しています。
  </p>

</div>


    <!-- ▼ 学習のやり方セクション ▼ -->
    <div class="learn-section">
      <h2>📘 学習のやり方</h2>
      <p>交差点付きライントレースの学習では、次の手順で練習を進めましょう。</p>
      <ol class="learn-list">
        <li><b>緑検知の確認：</b> 緑のテープを設置し、カメラが正確に認識できるか確認します。</li>
        <li><b>動作テスト：</b> 緑を検出した際に右折・左折など正しい動作ができるか試します。</li>
        <li><b>判定調整：</b> 照明やカメラの角度によって認識精度が変化するため、閾値を微調整します。</li>
        <li><b>応用練習：</b> 複数の交差点を設置して、連続的な判断と制御を試みましょう。</li>
      </ol>
      <p>緑のマーカーを「指示信号」として扱うことで、より高度な自律走行制御に近づけます。</p>
    </div>

  </main>

</body>
</html>
